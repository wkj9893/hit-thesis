
\section{课题来源及研究的目的和意义}
深度数据包检测（Deep packet inspection，缩写为DPI），是一种计算机网络数据包过滤技术，通过对数据包的分析然后采取警报、阻塞、重定向、日志记录等相应操作。字符串匹配算法是DPI的核心组成部分，高效的字符串匹配算法能够提高整个DPI系统的运行效率。

如今，服务器通常会压缩要传输的数据，来减少传输量和延时。通过gzip算法\cite{RFC1952}，文本数据（HTML、CSS和JavaScript）的压缩率可以达到25\%，这意味着理论上我们对压缩数据的匹配效率最高可以达到未压缩数据的4倍。因此，本课题研究在压缩流量下的高性能匹配算法，可以应用于DPI系统提高其对压缩流量的匹配效率。


\section{国内外在该方向的研究现状及分析}
字符串匹配算法自20世纪就得到广泛的研究，从单模式匹配下的KMP算法\cite{knuth1977fast}、BM算法\cite{boyer1977fast}，到多模式匹配下的AC算法\cite{aho1975efficient}，在到Commentz-Walter算法\cite{commentz1979string}、Rabin–Karp算法\cite{karp1987efficient}。

针对压缩流量的字符串匹配算法（ACCH算法）最早在2011年被提出\cite{bremler2011accelerating}，随后针对压缩流量的正则表达式匹配算法（ARCH算法）\cite{becchi2015accelerating}也在2015年被提出。然后，2020年twins算法\cite{sun2020efficient}被提出，进一步提高了对压缩流量匹配的效率。

目前，针对压缩流量的字符串匹配算法中都基于AC算法，我们可以对AC算法作出改进来进一步提高算法的运行效率\cite{李雪莹2004字符串匹配技术研究}。并且，我们可以选用其他多模式匹配算法，在特定场景下代替AC算法。

\section{主要研究内容}
本课题研究内容主要是实现在压缩流量场景下的高性能字符串匹配算法，可以应用于DPI系统检测压缩数据。

\subsection{gzip算法}
gzip算法\cite{RFC1952}是现在压缩HTTP流量最常用的算法，超过90\%的Alexa前五百名网站都使用gzip算法作为默认压缩算法。gzip算法基于DEFLATE算法，首先通过LZ77算法对内容进行压缩，然后再进行哈夫曼编码（Huffman coding）。LZ77算法扫描时，记录首次出现的字符串位置，将后面与该字符串相同的字符串记录为二元组<length,distance>，其中length表示字符串的长度，distance表示当前字符串与最早相同字符串的距离。例如，字符串abcdefabcd可以被压缩为abcdef<6,4>。假设一个字符串的长度是20字节，那么这个字符串以3字节的二元组表示，压缩率可以达到3/20。



\subsection{朴素算法}
对压缩流量最简单的匹配方法：每次遇到压缩数据的二元组，根据长度和距离确定其所指向的原字符串，然后对原字符串进行匹配。假设匹配压缩数据的长度为n，压缩率是m\%，如果使用基于DFA的AC算法，匹配时间为n/m。

\subsection{AC算法}
AC算法是最知名的多模式匹配算法，被广泛应用于snort等DPI系统,原论文\cite{aho1975efficient}提出两种方法，一种是通过构建goto函数、failure函数、output函数，可以看作构建一个NFA。然后根据字符的输入进行状态的转移，如果goto函数不为0进入下一个状态并向前移动，否则根据fail函数只进行状态的转移。如果状态刚好处于output函数，匹配成功相应的模式串。由于文本总长度为n，每输入一个字符，要么根据goto函数进入新状态并且向前移动，要么根据failure函数进入与当前状态后缀的最长前缀的状态并且不移动，由于状态0必定会发生移动，因此总的匹配时间小于$2n$。假设所有模式串的总长度为$m$,要搜索的文本长度为$n$，状态节点的数量小于$m$，总的空间复杂度小于$3m$

除了这种方式外，还可以构建DFA，思路是将goto函数和failure函数用一个二维数组代替（full matrix representation），二维数组保存了所有状态接收一个字符进入的新状态。假设二维数组为arr，二维数组的行数是所有的状态数量，列数通常是256（单个字节的最大值），arr[i][j]=k表示状态i接收j对应单个字节的输入进入状态k。根据DFA构建的AC算法从状态0开始，每接收一个字符进入一个新的状态并向前移动，因此总的匹配时间是$n$。然而由于这种方法没有进行压缩，总的空间复杂度为$256m$，所需内存空间较NFA更大，实际情况往往采用第一种方法。



\subsection{Twins算法}
Twins算法借助gzip压缩的信息实现对压缩数据的高效匹配。AC的DFA是确定性的，给定当前状态s和输入c，下一个状态被唯一确定。因此，对压缩数据的二元组，如果在某一位置状态与对应的第一个字符串相同，后面的状态也将完全相同，就可以直接跳过这些状态转移。例如，对于abcdef<6,4>，如果我们要匹配的模式是abcd，那么由于二元组之前的状态和初始状态相同，因此我们可以直接跳过最后的二元组。


\section{研究方案}
选取Alexa.com和Alexa.cn前500名的网站作为原始流量数据，选取不同数量的snort规则（snort24，snort31，snort34，snort135）作为需要匹配的正则表达式，。首先将正则表达式转化为相应的DFA，然后实现已经提出的不同压缩流量字符串匹配算法，并在相同压缩数据场景下进行比较。然后选取测试结果最好的算法，改进其中的AC算法，得到效率更高的算法。

\section{进度安排，预期达到的目标}

2021.11-2021.12：查询各种压缩流量下的字符串匹配算法的原论文并进行实现，在测试数据下测试其正确性

2022.1-2022.2：对实现的程序在收集到的压缩数据下进行测试，比较运行效率和占用内存

2022.3：根据比较的结果，改进算法，实现压缩流量场景下的高性能算法，并在收集的流量数据下与原匹配算法进行比较

2022.4：根据最终结果，完成毕业论文

\section{课题已具备和所需的条件、经费}

已具备的条件和经费：一台装有Linux系统的x86\_64笔记本电脑

所需的条件和经费：无


\section{研究过程中可能遇到的困难和问题，解决的措施}

预计可能遇到的问题：
\begin{enumerate}
  \item 对字符串匹配算法的优化、压缩没有太深的了解
  \item snort规则是正则表达式，需要首先转化为DFA才能进行匹配
\end{enumerate}

解决的措施：
\begin{enumerate}
  \item 在实现字符串匹配算法的同时进一步学习，同时查阅各算法的原论文，掌握其思想。
  \item 许多库函数实现了正则表达式转化为DFA，可以直接调用或者自己根据正则表达式转化为DFA的方法\cite{张树壮2011面向网络安全的正则表达式匹配技术}实现。
\end{enumerate}


\section{主要参考文献}


\bibliographystyle{hithesis}
\bibliography{references}
